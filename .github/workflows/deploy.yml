name: Deploy Backend to Production

on:
  push:
    branches: [ main ]
    paths:
      - 'backend/**'
      - 'docker-compose.dev.yml'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:  # Allow manual trigger

env:
  DEPLOYMENT_DIR: /opt/sidechain
  DOCKER_COMPOSE_FILE: docker-compose.dev.yml

jobs:
  deploy:
    name: Deploy Backend
    runs-on: ubuntu-latest
    environment: production  # Optional: use GitHub environments for secrets

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy via SSH
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.DEPLOY_SERVER_HOST }}
          username: ${{ secrets.DEPLOY_SERVER_USER }}
          port: ${{ secrets.DEPLOY_SERVER_PORT }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          script_stop: true  # Stop on first error
          script: |
            set -euo pipefail

            echo "=== Deploying Sidechain Backend ==="
            cd ${{ env.DEPLOYMENT_DIR }}

            # Pull latest code
            echo "→ Pulling latest code from main branch..."
            git fetch origin main
            git reset --hard origin/main

            # Check if docker-compose file exists
            if [ ! -f "${{ env.DOCKER_COMPOSE_FILE }}" ]; then
              echo "✗ Docker compose file not found: ${{ env.DOCKER_COMPOSE_FILE }}"
              exit 1
            fi

            # Load environment variables
            if [ ! -f .env ]; then
              echo "✗ .env file not found. Please configure it first."
              exit 1
            fi

            echo "→ Sourcing environment variables..."
            set -a
            source .env
            set +a

            # Validate critical environment variables
            required_vars=(
              "POSTGRES_USER"
              "POSTGRES_PASSWORD"
              "POSTGRES_DB"
              "JWT_SECRET"
            )

            for var in "${required_vars[@]}"; do
              if [ -z "${!var:-}" ]; then
                echo "✗ Missing required environment variable: $var"
                exit 1
              fi
            done

            # Stop old containers gracefully
            echo "→ Stopping old containers..."
            docker-compose -f "${{ env.DOCKER_COMPOSE_FILE }}" down || true

            # Build and start new containers
            echo "→ Building and starting containers..."
            docker-compose -f "${{ env.DOCKER_COMPOSE_FILE }}" up -d --build

            # Wait for services to be ready
            echo "→ Waiting for services to be ready..."
            sleep 5

            # Check if containers are running
            echo "→ Checking container status..."
            docker-compose -f "${{ env.DOCKER_COMPOSE_FILE }}" ps

            # Check API health
            echo "→ Checking API health..."
            max_attempts=30
            attempt=0
            while [ $attempt -lt $max_attempts ]; do
              if curl -sf http://localhost:${BACKEND_PORT:-8787}/health > /dev/null 2>&1; then
                echo "✓ API is healthy"
                break
              fi
              attempt=$((attempt + 1))
              if [ $attempt -eq $max_attempts ]; then
                echo "✗ API failed to become healthy after $max_attempts attempts"
                docker-compose -f "${{ env.DOCKER_COMPOSE_FILE }}" logs
                exit 1
              fi
              echo "  Attempt $attempt/$max_attempts - waiting for API..."
              sleep 1
            done

            # Show deployment info
            echo ""
            echo "=== Deployment Complete ==="
            echo "Server: ${{ secrets.DEPLOY_SERVER_HOST }}"
            echo "API: http://${{ secrets.DEPLOY_SERVER_HOST }}:${BACKEND_PORT:-8787}"
            echo ""
            docker-compose -f "${{ env.DOCKER_COMPOSE_FILE }}" ps

      - name: Notify on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '❌ Deployment failed. Check the workflow run for details.'
            })

  notify:
    name: Send Deployment Notification
    runs-on: ubuntu-latest
    needs: deploy
    if: always()
    steps:
      - name: Deployment status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "✓ Deployment successful to ${{ secrets.DEPLOY_SERVER_HOST }}"
          else
            echo "✗ Deployment failed"
            exit 1
          fi
