#!/usr/bin/env python3
"""
Generate Emoji.h - Programmatically creates a C++ header file with all emojis from CSV.

Fetches emoji data from GitHub Gist and generates Emoji.h with constants.
"""

import sys
import urllib.request
import csv
from pathlib import Path
from io import StringIO


def unicode_to_utf8_hex(emoji_char):
    """Convert a Unicode character to its UTF-8 hex encoding string."""
    utf8_bytes = emoji_char.encode('utf-8')
    return ''.join(f'\\x{b:02X}' for b in utf8_bytes)


def description_to_cpp_name(description):
    """Convert description to a valid C++ identifier."""
    # Remove quotes, special chars, convert to uppercase with underscores
    name = description.strip().strip('"')
    # Replace spaces and special chars with underscores
    name = name.replace(' ', '_').replace('-', '_').replace("'", '').replace(',', '')
    # Remove invalid characters
    name = ''.join(c if c.isalnum() or c == '_' else '' for c in name)
    # Remove multiple underscores
    while '__' in name:
        name = name.replace('__', '_')
    # Remove leading/trailing underscores
    name = name.strip('_')
    # Ensure it doesn't start with a number
    if name and name[0].isdigit():
        name = 'E_' + name
    return name.upper()


def fetch_emoji_csv():
    """Fetch the emoji CSV from GitHub Gist."""
    url = 'https://gist.githubusercontent.com/bfeldman89/fb25ddb63bdaa6de6ab7ac946acde96f/raw'
    print(f"Fetching emoji data from {url}...")
    try:
        with urllib.request.urlopen(url) as response:
            return response.read().decode('utf-8')
    except Exception as e:
        print(f"Error fetching CSV: {e}")
        sys.exit(1)


def parse_csv(csv_content):
    """Parse the CSV content and extract emoji and descriptions."""
    emojis = []
    
    # The CSV has emoji in first column, description in second column
    lines = csv_content.strip().split('\n')
    
    for line in lines:
        line = line.strip()
        if not line or line.startswith('break'):
            continue
        
        # Parse CSV line - emoji might have comma, so we need to handle it carefully
        # Format is: emoji, "Description"
        parts = line.split(',', 1)
        if len(parts) != 2:
            continue
        
        emoji_char = parts[0].strip()
        description = parts[1].strip()
        
        # Skip empty emojis
        if not emoji_char:
            continue
        
        emojis.append({
            'char': emoji_char,
            'description': description,
            'utf8_hex': unicode_to_utf8_hex(emoji_char),
            'cpp_name': description_to_cpp_name(description)
        })
    
    return emojis


def generate_emoji_header(emojis, output_path):
    """Generate the Emoji.h header file."""
    print(f"Generating {output_path}...")
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write('#pragma once\n\n')
        f.write('#include <JuceHeader.h>\n\n')
        f.write('//==============================================================================\n')
        f.write('/**\n')
        f.write(' * Emoji - Centralized emoji constants for the Sidechain plugin\n')
        f.write(' *\n')
        f.write(' * This file is auto-generated. Do not edit manually.\n')
        f.write(' * Generated by: scripts/generate_emoji_header.py\n')
        f.write(' * Source: https://gist.github.com/bfeldman89/fb25ddb63bdaa6de6ab7ac946acde96f\n')
        f.write(' *\n')
        f.write(' * Usage:\n')
        f.write(' *   #include "util/Emoji.h"\n')
        f.write(' *\n')
        f.write(' *   juce::String smile = Emoji::GRINNING_FACE;\n')
        f.write(' *   button->setButtonText(Emoji::THUMBS_UP);\n')
        f.write(' */\n')
        f.write('namespace Emoji\n')
        f.write('{\n\n')
        
        # Write all emojis as constants (skip duplicates)
        seen_names = set()
        for emoji_info in emojis:
            cpp_name = emoji_info['cpp_name']
            utf8_hex = emoji_info['utf8_hex']
            description = emoji_info['description'].strip().strip('"')
            emoji_char = emoji_info['char']
            
            # Skip duplicates (use first occurrence)
            if cpp_name in seen_names:
                continue
            seen_names.add(cpp_name)
            
            # Write constant
            f.write(f'    inline const juce::String {cpp_name} = juce::String(juce::CharPointer_UTF8("{utf8_hex}"));')
            f.write(f'  // {emoji_char} {description}\n')
        
        f.write('\n}  // namespace Emoji\n')
    
    print(f"✅ Generated {output_path}")
    print(f"   Total emojis: {len(emojis)}")


def main():
    """Main entry point."""
    script_dir = Path(__file__).parent
    repo_root = script_dir.parent
    output_path = repo_root / 'plugin' / 'source' / 'util' / 'Emoji.h'
    
    # Ensure output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Fetch and parse CSV
    csv_content = fetch_emoji_csv()
    emojis = parse_csv(csv_content)
    
    print(f"Parsed {len(emojis)} emojis from CSV")
    
    # Generate header file
    generate_emoji_header(emojis, output_path)
    print(f"\n✨ Done! Header file generated at: {output_path}")


if __name__ == '__main__':
    main()
